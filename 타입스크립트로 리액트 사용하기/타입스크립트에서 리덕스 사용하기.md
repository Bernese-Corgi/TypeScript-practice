# 타입스크립트에서 리덕스 사용하기

- [타입스크립트에서 리덕스 사용하기](#타입스크립트에서-리덕스-사용하기)
  - [카운터 리덕스 모듈 예제](#카운터-리덕스-모듈-예제)
    - [1. 액션](#1-액션)
    - [2. 리듀서 만들기](#2-리듀서-만들기)
    - [3. 프로젝트에 리듀서 적용](#3-프로젝트에-리듀서-적용)
    - [4. Counter 컴포넌트 (Presentational Component)](#4-counter-컴포넌트-presentational-component)
    - [5. CounterContainer 컨테이너 (Contational Component)](#5-countercontainer-컨테이너-contational-component)
    - [6. App 컴포넌트에서 렌더링](#6-app-컴포넌트에서-렌더링)

## 카운터 리덕스 모듈 예제

### 1. 액션

**액션 타입 선언**

`as const` : 액션 객체를 만들때, `action.type`의 값을 추론하는 과정에서 `action.type`이 `string` 으로 추론되지 않고 `'counter/INCREASE'`와 같이 <u>실제 문자열 값으로 추론</u> 되도록 해줍니다.

<span style="color: gray">▾ src/modules/counter.ts</span>

```tsx
const INCREASE = 'counter/INCREASE' as const;
```

**액션 생성 함수**

<span style="color: gray">▾ src/modules/counter.ts

```tsx
// 액션 생성함수
export const increase = () => ({
  type: INCREASE,
});

export const decrease = () => ({
  type: DECREASE,
});

export const increaseBy = (diff: number) => ({
  type: INCREASE_BY,
  payload: diff,
});
```

액션에 부가적으로 필요한 값을 `payload` 라는 이름으로 통일합니다. (FSA)

> FSA
> 이 규칙을 적용하면 액션들이 모두 비슷한 구조로 이루어져있게 되어 추후 다룰 때도 편하고 읽기 쉽고, 액션 구조를 일반화함으로써 액션에 관련된 라이브러리를 사용할 수 있게 해준다.
> 다만, 무조건 꼭 따를 필요는 없습니다.
> [FSA](https://github.com/redux-utilities/flux-standard-action)

---

### 2. 리듀서 만들기

**초기상태와 상태의 타입을 선언**

<span style="color: gray">▾ src/modules/counter.ts

```tsx
// 이 리덕스 모듈에서 관리할 상태의 타입을 선언
type CounterState = {
  count: number;
};

const initialState: CounterState = {
  count: 0,
};
```

**모든 액션 객체들에 대한 타입을 준비한다.**

- `ReturnType<typeof _____>`는 특정 함수의 반환값을 추론한다.
- 상단부에서 액션타입을 선언할 떄 `as const`를 하지 않으면 이 부분이 제대로 작동하지 않는다.

<span style="color: gray">▾ src/modules/counter.ts

```tsx
// 모든 액체 객체들에 대한 타입 선언
type CounterAction =
  | ReturnType<typeof increase>
  | ReturnType<typeof decrease>
  | ReturnType<typeof increaseBy>;

// 아래 두 코드와 같은 의미이다.
// 1.
// type CounterAction =
//   | { type: typeof INCREASE }
//   | { type: typeof DECREASE }
//   | { type: typeof INCREASEBY }

// 2.
// typeof CounterAction =
//   | { type: 'counter/INCREASE' }
//   | { type: 'counter/DECREASE' }
//   | { type: 'counter/INCREASEBY' }
```

**리듀서 함수 작성**

- 리듀서에서는 state와 함수의 반환값이 일치하도록 작성한다.
- 매개변수 state와 action에 타입을 각각 지정한다.

<span style="color: gray">▾ src/modules/counter.ts</span>

```tsx
// 리듀서 함수
function counter(
  // state의 초기값은 initialState이고, 타입은 CouterState이다.
  state: CounterState = initialState,
  action: CounterAction
): CounterState /* state와 함수의 반환값의 타입이 일치하도록 작성 */ {
  switch (action.type) {
    case INCREASE:
      return { count: state.count + 1 };
    case DECREASE:
      return { count: state.count - 1 };
    case INCREASE_BY:
      return { count: state.count + action.payload };
    default:
      return state;
  }
}

export default counter;
```

### 3. 프로젝트에 리듀서 적용

**modules 폴더의 index.ts 파일에 `rootReducer`를 생성한다.**

<span style="color: gray">▾ src/modules/index.ts</span>

```tsx
import { combineReducers } from 'redux';
import counter from './counter';

const rootReducer = combineReducers({
  counter,
});
```

**루트 리듀서의 반환값을 유추**

- rootReducer도 함수이므로, 반환값을 유추할 수 있다.
- 추후 이 타입을 컨테이너 컴포넌트에서 불러와서 사용해야 하므로 내보낸다.

<span style="color: gray">▾ src/modules/index.ts</span>

```tsx
// 루트 리듀서의 반환값를 유추
export type RootState = ReturnType<typeof rootReducer>;
```

<span style="color: gray">▾ src/modules/index.ts</span>

```tsx
// 루트 리듀서를 내보내기
export default rootReducer;
```

**Provider 컴포넌트를 통해 리듀서를 프로젝트 전체에 적용**

<span style="color: gray">▾ src/index.tsx</span>

```tsx
import { Provider } from 'react-redux';
import { createStore } from 'redux';
import rootReducer from './modules';

// 스토어 생성
const store = createStore(rootReducer);

// App 컴포넌트를 Provider 컴포넌트로 감싼다.
ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```

### 4. Counter 컴포넌트 (Presentational Component)

<span style="color: gray">▾ src/components/Counter.tsx</span>

```tsx
import React from 'react';

type CounterProps = {
  count: number;
  onIncrease: () => void;
  onDecrease: () => void;
  onIncreaseBy: (diff: number) => void;
};

function Counter({
  count,
  onIncrease,
  onDecrease,
  onIncreaseBy,
}: CounterProps) {
  return (
    <div>
      <h1>{count}</h1>
      <button onClick={onIncrease}>+1</button>
      <button onClick={onDecrease}>-1</button>
      <button onClick={() => onIncreaseBy(5)}>+5</button>
    </div>
  );
}

export default Counter;
```

### 5. CounterContainer 컨테이너 (Contational Component)

<span style="color: gray">▾ src/container/CounterContainer.tsx</span>

```tsx
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { RootState } from '../modules';
import { increase, decrease, increaseBy } from '../modules/counter';
import Counter from '../components/Couter';

function CounterContainer() {
  // 상태를 조회합니다. 상태를 조회 할 때에는 state 의 타입을 RootState 로 지정해야합니다.
  const count = useSelector((state: RootState) => state.counter.count);
  const dispatch = useDispatch(); // 디스패치 함수를 가져옵니다

  // 각 액션들을 디스패치하는 함수들을 만들어줍니다
  const onIncrease = () => {
    dispatch(increase());
  };

  const onDecrease = () => {
    dispatch(decrease());
  };

  const onIncreaseBy = (diff: number) => {
    dispatch(increaseBy(diff));
  };

  return (
    <Counter
      count={count}
      onIncrease={onIncrease}
      onDecrease={onDecrease}
      onIncreaseBy={onIncreaseBy}
    />
  );
}

export default CounterContainer;
```

### 6. App 컴포넌트에서 렌더링

<span style="color: gray">▾ src/App.tsx</span>

```tsx
import React from 'react';
import CounterContainer from './container/CounterContainer';

function App() {
  return (
    <div className="App">
      <CounterContainer />
    </div>
  );
}

export default App;
```
